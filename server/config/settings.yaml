database_presets:

  # ============================================================================
  # ORACLE DATABASES
  # ============================================================================
  transformer_master:
    type: oracle
    user: stg
    password: stg90
    dsn: stgrndm-np-01.qa.bos.credorax.com:1521/stgdev

  way4_docker8:
    type: oracle
    user: inform
    password: Term1k50
    dsn: docker-lin07.dev1.bos.credorax.com:15208/orclpdb1

  way4_docker7:
    type: oracle
    user: inform
    password: Term1k50
    dsn: docker-lin07.dev1.bos.credorax.com:15207/orclpdb1

  # ============================================================================
  # MYSQL DATABASES
  # ============================================================================
  mysql_devdb03_avi:
    type: mysql
    host: devdb03.dev.bos.credorax.com
    port: 3306
    user: inform
    password: inform
    database: avi
    version: "8.0.40-commercial"
    notes: "MySQL Enterprise Server - Commercial"

server:
  name: oracle_performance_mcp

# ============================================================================
# LOGGING CONFIGURATION
# ============================================================================
logging:
  level: DEBUG  # DEBUG, INFO, WARNING, ERROR
  show_tool_calls: true  # Log full tool invocations from LLM
  show_sql_queries: true  # Log actual SQL queries executed (verbose)

# ============================================================================
# MYSQL SQL ANALYSIS CONFIGURATION
# ============================================================================
mysql_analysis:
  
  # ========================================
  # OUTPUT FORMAT (Simple)
  # ========================================
  output_preset: "standard"  # standard | compact | minimal
  
  # Presets explained:
  # 
  # STANDARD - Full analysis (RECOMMENDED for MySQL)
  #   • EXPLAIN FORMAT=JSON plan
  #   • All table statistics (rows, size, engine)
  #   • Index structure + usage statistics
  #   • Duplicate index detection
  #   • Best for: Complete MySQL analysis
  #   • Size: ~15K tokens
  # 
  # COMPACT - Essential data only
  #   • JSON plan only
  #   • Tables in query + row counts
  #   • Index structure (no usage stats)
  #   • Best for: Quick analysis, token limits
  #   • Size: ~8K tokens
  # 
  # MINIMAL - Quick check
  #   • JSON plan only
  #   • Table row counts
  #   • No index details
  #   • Best for: Fast feedback, simple queries
  #   • Size: ~5K tokens
  
  # ========================================
  # DATA COLLECTION CONTROL (Advanced)
  # ========================================
  # Fine-tune what data to collect
  
  # === CORE ANALYSIS (Cannot be disabled) ===
  core:
    execution_plan:
      enabled: true
      description: "EXPLAIN FORMAT=JSON showing optimizer's execution strategy"
      criticality: CRITICAL
      note: "Never executes actual SQL - only simulates plan"
      
    plan_details:
      enabled: true
      description: "Detailed plan steps with costs, access types, filtering"
      criticality: CRITICAL
      why_needed: "Shows join methods, index usage, full table scans"

  # === METADATA (Recommended) ===
  metadata:
    table_statistics:
      enabled: true
      description: "Row counts, storage engine, data size, index size"
      criticality: HIGH
      why_needed: "Optimizer uses for cardinality estimates"
      performance_impact: LOW
      tables_accessed: [information_schema.TABLES]
      
    index_statistics:
      enabled: true
      description: "Index structure, columns, cardinality, uniqueness"
      criticality: HIGH
      why_needed: "Shows available indexes and their composition"
      performance_impact: LOW
      tables_accessed: [information_schema.STATISTICS]

  # === RUNTIME DIAGNOSTICS (Production insights) ===
  runtime:
    index_usage_stats:
      enabled: true
      description: "Real index usage from performance_schema (reads, writes, latency)"
      criticality: HIGH
      why_needed: "Identifies UNUSED indexes and hot indexes in production"
      performance_impact: LOW
      requires: "performance_schema enabled"
      tables_accessed: [performance_schema.table_io_waits_summary_by_index_usage]
      fallback_on_error: true
      note: "Shows which indexes are actually used vs. just defined"
      
    duplicate_index_detection:
      enabled: true
      description: "Detects redundant indexes (same columns, same order)"
      criticality: MEDIUM
      why_needed: "Cleanup opportunities - save disk space and write performance"
      performance_impact: NEGLIGIBLE
      note: "Computed from information_schema.STATISTICS"

# ============================================================================
# ORACLE SQL ANALYSIS CONFIGURATION
# ============================================================================
oracle_analysis:
  
  # ========================================
  # OUTPUT FORMAT (Simple)
  # ========================================
  output_preset: "compact"  # standard | compact | minimal
  
  # Presets explained:
  # 
  # STANDARD - Full analysis for human review
  #   • Text plan (DBMS_XPLAN) + JSON plan
  #   • All tables/indexes (even if not in plan)
  #   • All constraints and detailed stats
  #   • Best for: Reports, comprehensive analysis
  #   • Size: ~40K tokens
  # 
  # COMPACT - Optimized for LLM analysis (RECOMMENDED)
  #   • JSON plan only (no duplicate text)
  #   • Only tables/indexes in execution plan
  #   • Essential stats only
  #   • Best for: AI analysis, cost optimization
  #   • Size: ~20K tokens
  # 
  # MINIMAL - Quick analysis
  #   • JSON plan only
  #   • Plan objects + table row counts only
  #   • No detailed column stats or constraints
  #   • Best for: Fast feedback, simple queries
  #   • Size: ~12K tokens
  
  # ========================================
  # DATA COLLECTION CONTROL (Advanced)
  # ========================================
  # Fine-tune what data to collect
  # (Output preset controls what gets returned)
  
  # === CORE ANALYSIS (Cannot be disabled - fundamental) ===
  core:
    execution_plan:
      enabled: true
      description: "EXPLAIN PLAN showing optimizer's execution strategy"
      criticality: CRITICAL
      note: "Never executes actual SQL - only simulates plan"
      
    plan_details:
      enabled: true
      description: "Detailed plan steps with costs, cardinality, predicates"
      criticality: CRITICAL
      why_needed: "Shows filtering, join methods, access paths"

  # === METADATA (Highly Recommended) ===
  metadata:
    table_statistics:
      enabled: true
      description: "Row counts, blocks, avg_row_len, last_analyzed date"
      criticality: HIGH
      why_needed: "Optimizer relies on these for cardinality estimates"
      performance_impact: LOW
      tables_accessed: [ALL_TABLES]
      
    index_statistics:
      enabled: true
      description: "Index structure, clustering factor, distinct keys, status"
      criticality: HIGH
      why_needed: "Explains why indexes are/aren't chosen"
      performance_impact: LOW
      tables_accessed: [ALL_INDEXES]
      
    index_columns:
      enabled: true
      description: "Which columns are in each index"
      criticality: HIGH
      why_needed: "Matches predicates to available indexes"
      performance_impact: LOW
      tables_accessed: [ALL_IND_COLUMNS]
      
    column_statistics:
      enabled: true
      description: "Distinct values, nulls, density, histogram buckets"
      criticality: HIGH
      why_needed: "Detects data skew affecting cardinality estimates"
      performance_impact: LOW
      tables_accessed: [ALL_TAB_COL_STATISTICS]
      note: "Filters to columns mentioned in SQL only"
      
    constraints:
      enabled: true
      description: "Primary keys, foreign keys, unique constraints"
      criticality: HIGH
      why_needed: "Optimizer uses for join elimination & transformations"
      performance_impact: LOW
      tables_accessed: [ALL_CONSTRAINTS, ALL_CONS_COLUMNS]
      
    partition_info:
      enabled: true
      description: "Partition type, keys, count, subpartitioning"
      criticality: HIGH
      why_needed: "Essential for diagnosing partition pruning issues"
      performance_impact: LOW
      tables_accessed: [ALL_PART_TABLES, ALL_PART_KEY_COLUMNS]

  # === OPTIMIZER CONFIGURATION ===
  optimizer:
    parameters:
      enabled: true
      description: "Optimizer mode, index cost adj, dynamic sampling, etc."
      criticality: HIGH
      why_needed: "Explains WHY optimizer chose a specific plan"
      performance_impact: LOW
      requires_privileges: SELECT on V$PARAMETER
      tables_accessed: [V$PARAMETER]
      fallback_on_error: true

  # === STORAGE & SIZING ===
  storage:
    segment_sizes:
      enabled: true
      description: "Actual disk space (MB/GB) used by tables & indexes"
      criticality: MEDIUM
      why_needed: "Helps understand I/O costs for full scans"
      performance_impact: LOW
      requires_privileges: SELECT on DBA_SEGMENTS or USER_SEGMENTS
      tables_accessed: [DBA_SEGMENTS, USER_SEGMENTS]
      fallback: "Calculate from blocks * block_size if no access"
      fallback_on_error: true

  # === RUNTIME DIAGNOSTICS ===
  runtime:
    sql_execution_stats:
      enabled: false
      description: "Actual executions, buffer gets, CPU time, elapsed time"
      criticality: MEDIUM
      why_needed: "Shows real-world performance vs estimated"
      performance_impact: LOW
      requires_privileges: SELECT on V$SQL
      tables_accessed: [V$SQL]
      when_to_use: "Only when sql_id is provided for already-executed SQL"
      fallback_on_error: true
      
    partition_pruning_diagnostic:
      enabled: true
      description: "Detects when partition pruning fails despite partition key in WHERE"
      criticality: HIGH
      why_needed: "Critical for partitioned tables - prevents full scans"
      performance_impact: NEGLIGIBLE
      note: "Computed from existing data, no extra queries"

  # === COMPARISON MODE ===
  comparison:
    quick_compare:
      enabled: true
      description: "Fast plan comparison without re-fetching metadata"
      criticality: MEDIUM
      why_needed: "Speeds up iteration when testing query improvements"
      performance_impact: LOW
      note: "Only runs EXPLAIN PLAN, reuses metadata from previous analysis"

# ============================================================================
# ANALYSIS MODE PRESETS
# ============================================================================
# Quick shortcuts for common scenarios

analysis_modes:
  # ========================================
  # MYSQL ANALYSIS MODES
  # ========================================
  mysql:
    quick:
      description: "Fastest - plan and basic stats only"
      enabled_features:
        - core.execution_plan
        - core.plan_details
        - metadata.table_statistics
      
    standard:
      description: "Balanced - all metadata + index usage (RECOMMENDED)"
      enabled_features:
        - core.execution_plan
        - core.plan_details
        - metadata.table_statistics
        - metadata.index_statistics
        - runtime.index_usage_stats
        - runtime.duplicate_index_detection
      
    minimal:
      description: "Minimal - plan and row counts only"
      enabled_features:
        - core.execution_plan
        - core.plan_details
        - metadata.table_statistics
      
    # Custom mode - user can override individual features
    custom:
      description: "Use individual feature flags from mysql_analysis section"

  # ========================================
  # ORACLE ANALYSIS MODES
  # ========================================
  oracle:
    quick:
      description: "Fastest - plan and basic stats only"
      enabled_features:
        - core.execution_plan
        - core.plan_details
        - metadata.table_statistics
        - metadata.index_statistics
      
    standard:
      description: "Balanced - all metadata + optimizer params (recommended)"
      enabled_features:
        - all metadata features
        - optimizer.parameters
        - storage.segment_sizes
        - runtime.partition_pruning_diagnostic
      
    deep:
      description: "Comprehensive - everything enabled"
      enabled_features:
        - all features
        
    # Custom mode - user can override individual features
    custom:
      description: "Use individual feature flags from oracle_analysis section"
